/*---------------------------------------------------------------
*  Copyright 2005 by the Radiological Society of North America
*
*  This source software is released under the terms of the
*  RSNA Public License. (http://mirc.rsna.org/rsnapubliclicense)
*----------------------------------------------------------------*/

package org.rsna.mircsite.queryservice;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Calendar;
import java.util.Date;
import java.util.Enumeration;
import java.util.TimeZone;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.log4j.Logger;
import org.rsna.mircsite.queryservice.news.Item;
import org.rsna.mircsite.queryservice.news.NewsManager;
import org.rsna.mircsite.util.MircConfig;
import org.rsna.mircsite.util.Passport;
import org.rsna.mircsite.util.Passports;
import org.rsna.mircsite.util.ProxyServer;
import org.rsna.mircsite.util.StringUtil;
import org.rsna.mircsite.util.TomcatUser;
import org.rsna.mircsite.util.TomcatUsers;
import org.rsna.mircsite.util.Visa;
import org.rsna.mircsite.util.XmlUtil;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

/**
 * The MIRC Query Service servlet.
 * The Query Service is the interface into MIRC for users.
 * This servlet responds to both HTTP GET and POST.
 */
public class QueryService extends HttpServlet {

	private static final long serialVersionUID = 1123123213l;

	static final Logger logger = Logger.getLogger(QueryService.class);

	/**
	 * The servlet method that responds to an HTTP GET.
	 * If called with no query string, it returns the
	 * MIRC query page to the user in the response text.
	 * If called with a query string, it interprets the string as
	 * a query generated by the next or prev buttons on the query
	 * results page and services it accordingly.
	 * @param req The HttpServletRequest provided by the servlet container.
	 * @param res The HttpServletResponse provided by the servlet container.
	 * @throws ServletException if the servlet cannot handle the request.
	 */
	public void doGet(HttpServletRequest req, HttpServletResponse res)
											throws ServletException {
		PrintWriter out;
		//See what kind of GET this is by checking the query string.
		String queryString = req.getQueryString();
		if (queryString==null || queryString.trim().length()==0
			|| (req.getParameter("queryUID") == null)) {
			//This is a GET for the query page.
			try {
				File mircXSLFile = new File(getServletContext().getRealPath("/mirc.xsl"));
				MircConfig mircConfig = MircConfig.getInstance(mircXSLFile);
				Document mircXML = mircConfig.getMircXML();
				String username = req.getRemoteUser();
				if (username == null) username="";
				TomcatUsers tcUsers =
					TomcatUsers.getInstance(
						new File(getServletContext().getRealPath("/")));
				TomcatUser tcUser = tcUsers.getTomcatUser(username);
				if (tcUser == null) tcUser = new TomcatUser("guest","guest","none");
				Document options =
					XmlUtil.getDocument(getServletContext().getRealPath("/enumerated-values.xml"));
				Document species =
					XmlUtil.getDocument(getServletContext().getRealPath("/species-values.xml"));
				res.setContentType("text/html; charset=\"UTF-8\"");
				out = res.getWriter();
				out.print(
					XmlUtil.getTransformedText(
						mircXML,
						mircXSLFile,
						new Object[] {
							"username",      username,
							"localUser",	 tcUser.getUserXML(),
							"localServices", mircConfig.getLocalServicesXML(),
							"options",       options,
							"species",       species,
							"news",          getNews() }));
				out.close();
			}
			catch (Exception e) {
				//A serious error has occurred. Possibly mirc.xml or mirc.xsl are missing
				//from the query service root directory, or they may not parse. In any
				//case, we are dead. Since these are problems with the setup of the
				//server, throw a ServletException at the servlet container.
				throw new ServletException(e);
			}
		}
		else {
			//The query string is not blank or missing, so this is a GET from
			//the Next or Prev links on the query results page. Service it as
			//a POST of the query (which is encoded in the URL).
			serviceQuery(req,res,"");
		}
	}

	/**
	 * The servlet method that responds to an HTTP POST.
	 * This method interprets the form parameters as a query generated by the
	 * form on the query page and services it accordingly.
	 * @param req The HttpServletRequest provided by the servlet container.
	 * @param res The HttpServletResponse provided by the servlet container.
	 * @throws ServletException if the servlet cannot handle the request.
	 */
	public void doPost(HttpServletRequest req, HttpServletResponse res)
											throws ServletException {
		try { req.setCharacterEncoding("UTF-8"); }
		catch (Exception ignore) { }
		String requestContentType = req.getContentType();

		if (requestContentType==null) requestContentType="";
		if (requestContentType.toLowerCase().indexOf("application/x-www-form-urlencoded") >= 0) {

			//Create a UID for this query to help storage services that cache query results.
			String queryUID = req.getRemoteAddr() + "." + (new Date()).getTime();

			//Service the Query
			serviceQuery(req,res,queryUID);
		}
		else {
			res.setContentType("text/html; charset=\"UTF-8\"");
			try {
				PrintWriter out = res.getWriter();
				out.print(getHTMLMessage("Unsupported Content-Type: "+requestContentType));
			}
			catch (Exception e) { }
		}
	}

	// This function actually services the query for the doGet and doPost methods.
	// It transforms the form parameters into a MIRCquery XML object,
	// sends the MIRCquery to all the selected MIRC storage services, collates
	// the responses into a single HTML page, and returns the page to the user
	// in the response text.
	//
	// queryUID is a unique identifier of this query. It is used to assist
	// storage services that can cache their results. The queryUID is constructed
	// by the serviceQuery method when a new query is received (as opposed to one
	// that is a next page or prev page query from the query results page.
	private void serviceQuery(
			HttpServletRequest req,
			HttpServletResponse res,
			String queryUID) throws ServletException {

		try { req.setCharacterEncoding("UTF-8"); }
		catch (Exception ignore) { }
		try {
			res.setContentType("text/html; charset=\"UTF-8\"");

			//The cache control line below is removed. In principle, it would be nice
			//to disallow caching of query results in order to prevent the browser
			//from displaying incorrect results (when the results of the same
			//query would be different because the underlying documents have been
			//changed by some external process). Unfortunately, this causes the
			//browser to give a "Page has expired" error when hitting the Back
			//button from the display of a document. Since this is an important
			//capability, the lesser evil is to allow caching of query results.
			/*res.addHeader("Cache-Control","no-cache");*/

			PrintWriter out = res.getWriter();

			long requestTime = System.currentTimeMillis();

			//Get the form contents.
			String formInput = getFormInput(req);

			//Get the form contents into an XML DOM object.
			Document formXML = XmlUtil.getDocumentFromString(formInput);

			//If there was no separate queryUID, try to get one from the form.
			if (queryUID.equals("")) {
				try { queryUID = XmlUtil.getValueViaPath(formXML, "formdata/queryUID"); }
				catch (Exception e) { queryUID = ""; }
			}

			//Create the MIRCquery XML object from the formXML object.
			String[] mircQueryParms = {"queryUID",queryUID};
			String mircQueryString =
				XmlUtil.getTransformedText(
					formXML,
					new File(getServletContext().getRealPath("/MIRCquery.xsl")),
					mircQueryParms);

			//Get the mirc.xml file
			Document mircXML =
				XmlUtil.getDocument(getServletContext().getRealPath("/mirc.xml"));

			//Set up for the Next, Prev, and Home page links
			String homeURL = "/mirc/query"; //XmlUtil.getValueViaPath(mircXML, "mirc/queryservice@address");
			int firstresult = StringUtil.getInt(XmlUtil.getValueViaPath(formXML, "formdata/firstresult"));
			if (firstresult < 1) firstresult = 1;
			int maxresults = StringUtil.getInt(XmlUtil.getValueViaPath(formXML, "formdata/maxresults"));
			String showimages = XmlUtil.getValueViaPath(formXML, "formdata/showimages");
			String nextURL = makeAnchorURL(formXML,homeURL,queryUID,firstresult+maxresults,showimages);
			String prevURL = makeAnchorURL(formXML,homeURL,queryUID,Math.max(1,firstresult-maxresults),showimages);

			//Get the showimages parameter

			//Figure out what mode we are in (normal vs. casenavigator).
			//Note: randomize only applies to casenavigator.
			boolean casenavigator = false;
			String randomize = "";
			try {
				if (XmlUtil.getValueViaPath(formXML, "formdata/casenavigator").equals("yes"))
					casenavigator = true;
				randomize = XmlUtil.getValueViaPath(formXML, "formdata/randomize");
			}
			catch (Exception e) { }

			//If not in case navigator mode, start writing the response.
			//Note: the Content-Type was set before obtaining the
			//PrintWriter to allow the charset to be set to UTF-8.
			if (!casenavigator) writeResponseBeginning(out,mircXML,homeURL,nextURL,prevURL);

			//Set up for the transformation of query results.
			//We use a different XSL file and PrintWriter depending on the mode.
			//In case navigator mode, we capture all the transformed query results in a StringWriter
			//and then process them at the end. In normal mode, we just process and output as we go
			//because we don't have to have all the results before starting to write.
			String transformFilename = "/MIRCqueryresult.xsl";
			PrintWriter outPrintWriter = out;
			StringWriter stringWriter = new StringWriter();
			if (casenavigator) {
				transformFilename = "/CaseNavigatorURLList.xsl";
				outPrintWriter = new PrintWriter(stringWriter);
				//Put in a root element so we can parse the output as XML
				outPrintWriter.println("<navigatorurls>");
			}

			//Set up to poll the selected servers.
			//Get the list of selected servers.
			Element[] servers = getSelectedServers(formXML,mircXML);
			MircServer[] serverThreads = new MircServer[servers.length];

			//If the user is authenticated, get his passport.
			Passport passport = null;
			String username = req.getRemoteUser();
			if (username != null) {
				Passports passports =
					new Passports(new File(getServletContext().getRealPath("/")));
				passport = passports.getPassport(username);
			}

			//Get the configuration.
			MircConfig mircConfig = MircConfig.getInstance(new File(getServletContext().getRealPath("/")));

			//And get the timeout and convert to milliseconds.
			int timeout = mircConfig.getQueryTimeout() * 1000;

			//Set the proxy server parameters
			ProxyServer proxy = mircConfig.getProxyServer();
			String proxyCredentials = "";
			if (proxy.getProxyEnabled()) {
				proxy.setProxyProperties();
				if (proxy.authenticate()) proxyCredentials = proxy.getEncodedProxyCredentials();
			}
			else proxy.clearProxyProperties();

			//Send the mircquery to all the selected servers
			for (int i=0; i<servers.length; i++) {
				//Get the user's visa for this server.
				String address = servers[i].getAttribute("address");

				//Generate their visa
				Visa visa = null;
				if (mircConfig.isLocal(address) && username != null) {
					//If the queried server is this instance of Tomcat, then
					//create a visa automatically.
					TomcatUsers tcUsers = TomcatUsers.getInstance(new File(getServletContext().getRealPath("/")));
					TomcatUser tcUser = tcUsers.getTomcatUser(username);
					visa = new Visa(address, username, tcUser.password);
				}
				else {
					//Otherwise, get the visa from their passport.
					if (passport != null) visa = passport.getVisa(address);
				}

				//Create the thread for this server and start it.
				serverThreads[i] =
					new MircServer(
						address,
						visa,
						XmlUtil.getElementValue(servers[i]),
						mircQueryString,
						new File(getServletContext().getRealPath(transformFilename)),
						Integer.toString(firstresult),
						showimages,
						proxyCredentials);
				serverThreads[i].start();
			}

			//Get the responses
			if (!pollServers(outPrintWriter, serverThreads, timeout)) { //time out after the specified time
				//Interrupt the ones that didn't respond
				for (int i=0; i<servers.length; i++) {
					if (serverThreads[i] != null) serverThreads[i].interrupt();
				}
				//Get the responses from the laggards
				pollServers(outPrintWriter, serverThreads, 3000); //time out after 3 seconds
			}

			//Okay, if we are in normal mode, we can just put out the tagline and call it a day.
			if (!casenavigator) writeResponseEnd(out,requestTime);

			//If we are in case navigator mode, we now need to do all the processing.
			else {
				//First put in the end element.
				outPrintWriter.println("\n</navigatorurls>");
				//Then go do the work.
				writeCaseNavigatorResponse(out,stringWriter.toString(),homeURL,nextURL,prevURL,randomize);
			}
		}
		catch (Exception e) {
			//A serious error has occurred that we couldn't handle in the method itself.
			//Throw a ServletException at the servlet container. This will at least generate
			//a dump for the browser, and the user can screen capture the page and email it to
			//the poor soul who has written this code.
			throw new ServletException(e);
		}
	}

	// Poll the servers for a specified time and return:
	// 		true if all the servers responded
	// 		false if any server did not respond
	//
	private boolean pollServers (PrintWriter out, MircServer[] serverThreads, int timeout) {
		long startTime = System.currentTimeMillis();
		int activeServers = serverThreads.length;
		while ( (activeServers > 0) && ((System.currentTimeMillis()-startTime) <= timeout) ) {
			activeServers = 0;
			for (int i=0; i<serverThreads.length; i++) {
				if ((serverThreads[i]!=null) && (serverThreads[i].ready)) {
					out.print(serverThreads[i].result);
					serverThreads[i] = null;
				}
				if (serverThreads[i]!=null) activeServers++;
			}
			if (activeServers > 0) {
				try { Thread.sleep(500); } //wait for half a second and poll again
				catch (InterruptedException e) {}
			}
		}
		if (activeServers > 0) return false;
		return true;
	}

	// Create an XML string from the form data in the POST
	private String getFormInput(HttpServletRequest req) {
		Enumeration en = req.getParameterNames();
		String formInput = "<formdata>";
		String name;
		String values[];
		String s;
		String ss;
		while (en.hasMoreElements()) {
			name = (String) en.nextElement();
			values = req.getParameterValues(name);
			if (values != null) {
				for (int i=0; i<values.length; i++) {
					if (values[i].trim().length() > 0) {
						s = values[i].trim();
						//Protect against oddball characters in the query.
						//Replace things that would need to be coded as entities with spaces.
						s = s.replaceAll("[&<>']"," ");
						//If there is an odd number of " chars, then replace them all with spaces.
						ss = s.replaceAll("[^\"]","");
						if ((ss.length() | 1) != 0) s = s.replace("\""," ");
						formInput += "<" + name + ">" + s + "</" + name + ">";
					}
				}
			}
		}
		formInput += "</formdata>";
		return formInput;
	}

	// Create the URL for the next and prev page buttons on
	// the query results page. The URL has a query string that encodes the
	// current query, but with a different firstresult, allowing for paging.
	private String makeAnchorURL(Document formXML,
								 String serverURL,
								 String queryUID,
								 int firstresult,
								 String showimages) throws ServletException {
		String anchorString = serverURL + "?firstresult=" + firstresult + "&showimages=" + showimages;
		NodeList nodeList = formXML.getDocumentElement().getElementsByTagName("server");
		for (int i=0; i<nodeList.getLength(); i++) {
			anchorString += "&server=" + XmlUtil.getElementValue(nodeList.item(i));
		}
		nodeList = formXML.getDocumentElement().getElementsByTagName("*");
		for (int i=0; i<nodeList.getLength(); i++) {
			String name = ((Element)(nodeList.item(i))).getTagName();
			if (!name.equals("firstresult") &&
					!name.equals("showimages") &&
					!name.equals("server") &&
					!name.equals("queryUID")) {
				anchorString += "&" + name + "=" + XmlUtil.getElementValue(nodeList.item(i));
			}
		}
		if (queryUID.length() != 0) anchorString += "&queryUID=" + queryUID;
		return anchorString;
	}

	// Write out the beginning of the query results page, taking care of
	// the heading and the home, next and prev page buttons.
	private void writeResponseBeginning(PrintWriter out,
										Document mircXML,
										String homeURL,
										String nextURL,
										String prevURL) throws Exception {
		//Start writing the response.
		out.println("<html>");

		//Write the <head>...</head> section
		out.print(
			XmlUtil.getTransformedText(
				mircXML,
				new File(getServletContext().getRealPath("/MIRCqueryresulthead.xsl"))));

		//Now start the body section
		out.println("<body class=\"stdresults\" scroll=\"no\">");

		//Put out the page heading and the home, next and previous links
		String[] mqrbParms = {"homestring",homeURL,"nextstring",nextURL,"prevstring",prevURL};
		out.print(
			XmlUtil.getTransformedText(
				mircXML,
				new File(getServletContext().getRealPath("/MIRCqueryresultbody.xsl")),
				mqrbParms));

		//Put out the div that allows scrolling of only the results section of the window
		out.print(getResultsDiv());
	}

	// Write out the last part of the results, showing the elapsed
	// time and the current time.
	private void writeResponseEnd(PrintWriter out, long requestTime) {

		//Write out the total request time
		Date date = new Date();
		requestTime = (date.getTime() - requestTime)/100; //in tenths of a second
		String rt = "" + requestTime;
		rt = rt.substring(0,rt.length()-1) + "." + rt.substring(rt.length()-1,rt.length());
		out.println("<h3>Total request time = " + rt + " seconds");

		//... and the current time in Zulu
		Calendar now = Calendar.getInstance();
		TimeZone timeZone = TimeZone.getDefault();
		int zoneOffset = now.get(Calendar.ZONE_OFFSET)/(60*60*1000);
		int hour = now.get(Calendar.HOUR_OF_DAY);
		if (timeZone.inDaylightTime(date)) hour--;
		hour -= zoneOffset;
		if (hour < 0) hour += 24;
		if (hour > 24) hour -= 24;
		int minute = now.get(Calendar.MINUTE);
		if ((hour == 24) && (minute > 0)) hour = 0;
		out.println(" at " + StringUtil.intToString(hour,2) + StringUtil.intToString(minute,2) + "Z</h3>");

		//The end.
		out.println("</div>");
		out.println("</body>\n</html>");
	}

	// Produce the response for all the storage services
	// when the case navigator is selected. In this situation, we can't
	// just process the individual responses from the storage services one at
	// a time because we need to be able to randomize. In case navigator mode,
	// all the responses were written to a StringWriter as they came in and then
	// converted to a single string with all the responses in it. This is the
	// routine that processes that string and produces the content of the main
	// body of the query result page (the part that scrolls).
	private void writeCaseNavigatorResponse(PrintWriter out,
											String result,
											String homeURL,
											String nextURL,
											String prevURL,
											String randomize) {
		//Transform the result string
		try {
			String[] cnrParms = {"homestring",homeURL,"nextstring",nextURL,
								 "prevstring",prevURL,"randomize",randomize};
			out.print(
				XmlUtil.getTransformedText(
					result,
					new File(getServletContext().getRealPath("/CaseNavigatorResult.xsl")),
					cnrParms));
		}
		catch (Exception e) {
			out.print(getHTMLMessage(e.getMessage()));
		}
	}

	// Return an array of <server> nodes from the mirc.xml configuration
	// file corresponding to the servers that were selected in the form on the
	// query page.
	private Element[] getSelectedServers(Document formXML, Document mircXML) throws ServletException {
		NodeList formNodeList = formXML.getDocumentElement().getElementsByTagName("server");
		NodeList mircNodeList = mircXML.getDocumentElement().getElementsByTagName("server");
		//Handle the case where nothing is selected; return the first node.
		if (formNodeList.getLength() < 1) {
			Element[] s = new Element[1];
			s[0] = (Element)mircNodeList.item(0);
			return s;
		}
		//Handle the case where one or more servers are selected.
		Element[] servers = new Element[formNodeList.getLength()];
		for (int i=0; i<formNodeList.getLength(); i++) {
			servers[i] =
				(Element)mircNodeList.item(
						StringUtil.getInt(XmlUtil.getElementValue(formNodeList.item(i)))-1);
		}
		return servers;
	}

	// Produce the non-scrolling <div> element that contains the query results.
	private String getResultsDiv() {
		return 	"\n<div id=\"qrresults\" >\n";
	}

	// Generate an HTML page that lists a message.
	// It is used to inform a user that something uncorrectable has happened.
	private String getHTMLMessage(String messageString) {
			return "<html><head><title>Error</title></head><body>"
							+ "<p>" + messageString + "</p></body></html>";
	}

	private Document getNews() throws Exception {
		Document news = XmlUtil.getDocument();
		Element root = news.createElement("news");
		news.appendChild(root);
		NewsManager manager = new NewsManager();
		String xmlLink = getServletContext().getRealPath("news/news.rss");
		Item newsItem = manager.getNewestItem(xmlLink);
		if( newsItem != null ) {
			String titleText = newsItem.getTitle();
			if (titleText != null) {
				Element title = news.createElement("title");
				title.setTextContent(titleText);
				root.appendChild(title);
			}
			String imageLink = newsItem.getImageLink();
			if (imageLink != null) {
				Element image = news.createElement("image");
				image.setTextContent(imageLink);
				root.appendChild(image);
			}
			Element url = news.createElement("url");
			url.setTextContent(newsItem.getLink());
			root.appendChild(url);
		}
		return news;
	}

}
