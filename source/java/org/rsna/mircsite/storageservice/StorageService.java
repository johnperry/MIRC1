/*---------------------------------------------------------------
*  Copyright 2005 by the Radiological Society of North America
*
*  This source software is released under the terms of the
*  RSNA Public License (http://mirc.rsna.org/rsnapubliclicense)
*----------------------------------------------------------------*/

package org.rsna.mircsite.storageservice;

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.log4j.Logger;
import org.rsna.mircsite.util.*;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

/**
 * The MIRC Storage Service servlet.
 * <p>
 * The Storage Service provides indexing of the documents it stores
 * and responds to queries from Query Services.
 * <br>
 * This servlet responds to HTTP POST.
 * <br>
 * See the <a href="http://mirc.rsna.org/mircdocumentation">
 * MIRC documentation</a> for more more information.
 */
public class StorageService extends HttpServlet {

	static final Logger logger = Logger.getLogger(StorageService.class);

	/**
	 * The servlet method that responds to an HTTP POST.
	 * <p>
	 * This method interprets the parameters as a query generated by the
	 * Query Service, uses it to search the index, and returns a MIRCqueryresult.
	 * @param req The HttpServletRequest provided by the servlet container.
	 * @param res The HttpServletResponse provided by the servlet container.
	 */
	public void doPost(
				HttpServletRequest req,
				HttpServletResponse res
				) throws IOException, ServletException {

		try { req.setCharacterEncoding("UTF-8"); }
		catch (Exception ignore) { }
		res.setContentType("text/xml; charset=\"UTF-8\"");
		PrintWriter out = res.getWriter();

		//Check that this is a post of a MIRCquery.
		//Note that the test of the content type is not done
		//with .equals("text/xml") because sometimes the
		//content type header also includes the charset.
		String requestContentType = req.getContentType();
		if ((requestContentType != null) &&
				(requestContentType.toLowerCase().indexOf("text/xml") >= 0)) {

			//Yes, get the query
			int n;
			BufferedReader in = req.getReader();
			StringWriter sw = new StringWriter();
			char[] cbuf = new char[1024];
			while ((n = in.read(cbuf,0,1024)) != -1) { sw.write(cbuf,0,n); }
			String mircQueryString = sw.toString();

			//Parse the MIRCquery
			MircQuery mircQuery = null;
			try {
				Document mircQueryXML = XmlUtil.getDocumentFromString(mircQueryString);
				mircQuery = new MircQuery(mircQueryXML);
			}
			catch (Exception e) {
				out.print(
					XmlStringUtil.makeMQRString(
						"Error parsing the MIRCquery:"
						+ "<br/>Exception message: " + e.getMessage()
						+ "<br/>MIRCquery string length: " + mircQueryString.length()
						+ "<br/>MIRCquery string:<br/><br/>"
						+ XmlStringUtil.makeReadableTagString(mircQueryString)));
				out.flush();
				out.close();
				return;
			}

			//Get the user's credentials, if any.
			Visa visa = new Visa(req);
			TomcatUser tcUser = null;
			if ((visa.username != null) && !visa.username.equals("") &&
				(visa.password != null) && !visa.password.equals("")) {
				File rootDir = new File(getServletContext().getRealPath("/"));
				TomcatUsers tcUsers = TomcatUsers.getInstance(rootDir);
				tcUser = tcUsers.getTomcatUser(visa.username);
				if ((tcUser != null) && !visa.password.equals(tcUser.password)) {
					tcUser = null;
				}
			}
			if (tcUser != null) {
				tcUser.isAdmin = (tcUser.hasRole(StorageConfig.getAdminRoleName()) ||
									tcUser.hasRole(StorageConfig.getTomcatRoleName()));
				tcUser.isUser = (tcUser.hasRole(StorageConfig.getUserRoleName()));
			}

			//Get the index
			MircIndex index = MircIndex.getInstance();

			//Do the query and sort the results
			boolean isOpen = StorageConfig.getQueryMode().equals("open");
			MircIndexEntry[] mies = index.query(mircQuery, isOpen, tcUser);
			String orderBy = StorageConfig.getOrderBy();
			if (orderBy.equals("title"))
				index.sortByTitle(mies);
			else
				index.sortByLMDate(mies);

			//Get a document for the MIRCqueryresult
			Document doc = null;
			try { doc = XmlUtil.getDocument(); }
			catch (Exception ex) {
				String message = "Unable to create an XML document for the MIRCqueryresult";
				logger.error(message, ex);
				out.print( XmlStringUtil.makeMQRString(message) );
				out.flush();
				out.close();
				return;
			}

			//Select the requested page
			if (mircQuery.firstresult < 0) mircQuery.firstresult = 0;
			if (mircQuery.maxresults <= 0) mircQuery.maxresults = 1;
			Element root = doc.createElement("MIRCqueryresult");
			doc.appendChild(root);
			setPreamble(root, mies.length);

			//Important note: The imported node must be passed to fixResult.
			//Do not pass the node from the mies array (mies[i].md) and then
			//import the returned node. This would cause fixResult to modify
			//the object in the JDBM's cache, causing problems in the next query.
			String docbase = StorageConfig.getDocbase();
			int begin = mircQuery.firstresult - 1;
			int end = begin + mircQuery.maxresults;
			for (int i=begin; ((i<end) && (i<mies.length)); i++) {
				root.appendChild( fixResult(docbase, (Element)doc.importNode(mies[i].md, true), mircQuery) );
			}
			//Return the result.
			out.print(XmlUtil.toString(root));
			out.flush();
			out.close();
			return;
		}

		else {
			//Unknown content type
			out.print(
				XmlStringUtil.makeMQRString(
					"Unsupported Content-Type: "+req.getContentType()));
			out.flush();
			out.close();
		}
	}

	private void setPreamble(Element root, int matches) {
		Document doc = root.getOwnerDocument();
		Element preamble = doc.createElement("preamble");
		root.appendChild(preamble);
		String tagline = StorageConfig.getTagline().trim();
		if (!tagline.equals("")) {
			Element p = doc.createElement("p");
			Element b = doc.createElement("b");
			b.setTextContent(tagline);
			p.appendChild(b);
			preamble.appendChild(p);
		}
		Element p = doc.createElement("p");
		p.setTextContent("Total search matches: "+matches);
		preamble.appendChild(p);
	}

	private Element fixResult( String context, Element md, MircQuery mircQuery ) {
		//First fix the docref
		String docref = md.getAttribute("docref").trim();
		String path = md.getAttribute("filename").trim();
		md.removeAttribute("filename");
		if (docref.equals("")) {
			//There is no docref, use the context and the path.
			docref = context + path;
		}
		else {
			//docref is present, see what kind of a docref it is.
			if (docref.indexOf("://") != -1) {
				//docref is absolute. It does not need to be modified.
			}
			else if (docref.startsWith("/")) {
				//docref is relative to the root of the servlet.
				//In this implementation, the servlet is at context.
				//In principle, this means that the absolute path is
				//the sum of context and docref, except that
				//since context ends with "/" and docref starts with "/"
				//we have to be careful to remove one of the "/" characters.
				docref = context + docref.substring(1);
			}
			else {
				//docref is relative to the directory containing the MIRCdocument.
				//This can happen when a MIRCdocument is an index card for
				//another file type located in the same directory or a subdirectory.
				//The path contains the path to the MIRCdocument file, so we need
				//all the path up to the last "/".
				docref = context +
							path.substring(0,path.lastIndexOf("/")+1) +
								docref;
			}
		}
		String qps = "";
		if (mircQuery.unknown) qps += "unknown=yes";
		if (!mircQuery.bgcolor.equals("")) {
			if (!qps.equals("")) qps += "&";
			qps += "bgcolor="+mircQuery.bgcolor;
		}
		if (!mircQuery.display.equals("")) {
			if (!qps.equals("")) qps += "&";
			qps += "display="+mircQuery.display;
		}
		if (!mircQuery.icons.equals("")) {
			if (!qps.equals("")) qps += "&";
			qps += "icons="+mircQuery.icons;
		}
		if (!qps.equals("")) docref += "?" + qps;
		md.setAttribute("docref",docref);

		//Now fix the title and abstract elements and remove the alternative elements.
		Element title = null;
		Element altTitle = null;
		Element abs = null;
		Element altAbs = null;
		Element category = null;
		Node child = md.getFirstChild();
		while (child != null) {
			if (child.getNodeType() == Node.ELEMENT_NODE) {
				if (child.getNodeName().equals("title")) title = (Element)child;
				else if (child.getNodeName().equals("alternative-title")) altTitle = (Element)child;
				else if (child.getNodeName().equals("abstract")) abs = (Element)child;
				else if (child.getNodeName().equals("alternative-abstract")) altAbs = (Element)child;
				else if (child.getNodeName().equals("category")) category = (Element)child;
			}
			child = child.getNextSibling();
		}
		if (mircQuery.unknown) {
			if (altTitle != null) copy(altTitle, title, "title");
			else {
				while ((child = title.getFirstChild()) != null) title.removeChild(child);
				String titleString = "Unknown";
				if (category != null) {
					String cat = category.getTextContent().trim();
					if (!cat.equals("")) titleString += " - " + cat;
				}
				title.appendChild(title.getOwnerDocument().createTextNode(titleString));
			}
			if (altAbs != null)  copy(altAbs, abs, "abstract");
			else if (abs != null) md.removeChild(abs);
		}
		if (altTitle != null) md.removeChild(altTitle);
		if (altAbs != null) md.removeChild(altAbs);
		return md;
	}

	private void copy(Element from, Element to, String name) {
		if (to == null) {
			to = from.getOwnerDocument().createElement(name);
			from.getParentNode().insertBefore(to,from);
		}
		Node child;
		while ((child = to.getFirstChild()) != null) to.removeChild(child);
		while ((child = from.getFirstChild()) != null) {
			from.removeChild(child);
			to.appendChild(child);
		}
	}


}
